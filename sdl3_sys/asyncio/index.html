<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="SDL offers a way to perform I/O asynchronously. This allows an app to read or write files without waiting for data to actually transfer; the functions that request I/O never block while the request is fulfilled."><title>sdl3_sys::asyncio - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="sdl3_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../sdl3_sys/index.html">sdl3_<wbr>sys</a><span class="version">0.4.4+SDL3-3.2.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module asyncio</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#best-practices" title="Best Practices">Best Practices</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate sdl3_<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">sdl3_sys</a></span><h1>Module <span>asyncio</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/sdl3_sys/generated/asyncio.rs.html#1-695">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>SDL offers a way to perform I/O asynchronously. This allows an app to read
or write files without waiting for data to actually transfer; the functions
that request I/O never block while the request is fulfilled.</p>
<p>Instead, the data moves in the background and the app can check for results
at their leisure.</p>
<p>This is more complicated than just reading and writing files in a
synchronous way, but it can allow for more efficiency, and never having
framerate drops as the hard drive catches up, etc.</p>
<p>The general usage pattern for async I/O is:</p>
<ul>
<li>Create one or more <a href="struct.SDL_AsyncIOQueue.html" title="struct sdl3_sys::asyncio::SDL_AsyncIOQueue"><code>SDL_AsyncIOQueue</code></a> objects.</li>
<li>Open files with <a href="fn.SDL_AsyncIOFromFile.html" title="fn sdl3_sys::asyncio::SDL_AsyncIOFromFile"><code>SDL_AsyncIOFromFile</code></a>.</li>
<li>Start I/O tasks to the files with <a href="fn.SDL_ReadAsyncIO.html" title="fn sdl3_sys::asyncio::SDL_ReadAsyncIO"><code>SDL_ReadAsyncIO</code></a> or <a href="fn.SDL_WriteAsyncIO.html" title="fn sdl3_sys::asyncio::SDL_WriteAsyncIO"><code>SDL_WriteAsyncIO</code></a>,
putting those tasks into one of the queues.</li>
<li>Later on, use <a href="fn.SDL_GetAsyncIOResult.html" title="fn sdl3_sys::asyncio::SDL_GetAsyncIOResult"><code>SDL_GetAsyncIOResult</code></a> on a queue to see if any task is
finished without blocking. Tasks might finish in any order with success
or failure.</li>
<li>When all your tasks are done, close the file with <a href="fn.SDL_CloseAsyncIO.html" title="fn sdl3_sys::asyncio::SDL_CloseAsyncIO"><code>SDL_CloseAsyncIO</code></a>. This
also generates a task, since it might flush data to disk!</li>
</ul>
<p>This all works, without blocking, in a single thread, but one can also wait
on a queue in a background thread, sleeping until new results have arrived:</p>
<ul>
<li>Call <a href="fn.SDL_WaitAsyncIOResult.html" title="fn sdl3_sys::asyncio::SDL_WaitAsyncIOResult"><code>SDL_WaitAsyncIOResult</code></a> from one or more threads to efficiently block
until new tasks complete.</li>
<li>When shutting down, call <a href="fn.SDL_SignalAsyncIOQueue.html" title="fn sdl3_sys::asyncio::SDL_SignalAsyncIOQueue"><code>SDL_SignalAsyncIOQueue</code></a> to unblock any sleeping
threads despite there being no new tasks completed.</li>
</ul>
<p>And, of course, to match the synchronous <a href="../iostream/fn.SDL_LoadFile.html" title="fn sdl3_sys::iostream::SDL_LoadFile"><code>SDL_LoadFile</code></a>, we offer
<a href="fn.SDL_LoadFileAsync.html" title="fn sdl3_sys::asyncio::SDL_LoadFileAsync"><code>SDL_LoadFileAsync</code></a> as a convenience function. This will handle allocating a
buffer, slurping in the file data, and null-terminating it; you still check
for results later.</p>
<p>Behind the scenes, SDL will use newer, efficient APIs on platforms that
support them: Linux’s io_uring and Windows 11’s IoRing, for example. If
those technologies aren’t available, SDL will offload the work to a thread
pool that will manage otherwise-synchronous loads without blocking the app.</p>
<h3 id="best-practices"><a class="doc-anchor" href="#best-practices">§</a>Best Practices</h3>
<p>Simple non-blocking I/O–for an app that just wants to pick up data
whenever it’s ready without losing framerate waiting on disks to spin–can
use whatever pattern works well for the program. In this case, simply call
<a href="fn.SDL_ReadAsyncIO.html" title="fn sdl3_sys::asyncio::SDL_ReadAsyncIO"><code>SDL_ReadAsyncIO</code></a>, or maybe <a href="fn.SDL_LoadFileAsync.html" title="fn sdl3_sys::asyncio::SDL_LoadFileAsync"><code>SDL_LoadFileAsync</code></a>, as needed. Once a frame, call
<a href="fn.SDL_GetAsyncIOResult.html" title="fn sdl3_sys::asyncio::SDL_GetAsyncIOResult"><code>SDL_GetAsyncIOResult</code></a> to check for any completed tasks and deal with the
data as it arrives.</p>
<p>If two separate pieces of the same program need their own I/O, it is legal
for each to create their own queue. This will prevent either piece from
accidentally consuming the other’s completed tasks. Each queue does require
some amount of resources, but it is not an overwhelming cost. Do not make a
queue for each task, however. It is better to put many tasks into a single
queue. They will be reported in order of completion, not in the order they
were submitted, so it doesn’t generally matter what order tasks are
started.</p>
<p>One async I/O queue can be shared by multiple threads, or one thread can
have more than one queue, but the most efficient way–if ruthless
efficiency is the goal–is to have one queue per thread, with multiple
threads working in parallel, and attempt to keep each queue loaded with
tasks that are both started by and consumed by the same thread. On modern
platforms that can use newer interfaces, this can keep data flowing as
efficiently as possible all the way from storage hardware to the app, with
no contention between threads for access to the same queue.</p>
<p>Written data is not guaranteed to make it to physical media by the time a
closing task is completed, unless <a href="fn.SDL_CloseAsyncIO.html" title="fn sdl3_sys::asyncio::SDL_CloseAsyncIO"><code>SDL_CloseAsyncIO</code></a> is called with its
<code>flush</code> parameter set to true, which is to say that a successful result
here can still result in lost data during an unfortunately-timed power
outage if not flushed. However, flushing will take longer and may be
unnecessary, depending on the app’s needs.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.SDL_AsyncIO.html" title="struct sdl3_sys::asyncio::SDL_AsyncIO">SDL_<wbr>AsyncIO</a></div><div class="desc docblock-short">The asynchronous I/O operation structure.</div></li><li><div class="item-name"><a class="struct" href="struct.SDL_AsyncIOOutcome.html" title="struct sdl3_sys::asyncio::SDL_AsyncIOOutcome">SDL_<wbr>AsyncIO<wbr>Outcome</a></div><div class="desc docblock-short">Information about a completed asynchronous I/O request.</div></li><li><div class="item-name"><a class="struct" href="struct.SDL_AsyncIOQueue.html" title="struct sdl3_sys::asyncio::SDL_AsyncIOQueue">SDL_<wbr>AsyncIO<wbr>Queue</a></div><div class="desc docblock-short">A queue of completed asynchronous I/O tasks.</div></li><li><div class="item-name"><a class="struct" href="struct.SDL_AsyncIOResult.html" title="struct sdl3_sys::asyncio::SDL_AsyncIOResult">SDL_<wbr>AsyncIO<wbr>Result</a></div><div class="desc docblock-short">Possible outcomes of an asynchronous I/O task.</div></li><li><div class="item-name"><a class="struct" href="struct.SDL_AsyncIOTaskType.html" title="struct sdl3_sys::asyncio::SDL_AsyncIOTaskType">SDL_<wbr>AsyncIO<wbr>Task<wbr>Type</a></div><div class="desc docblock-short">Types of asynchronous I/O tasks.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.SDL_ASYNCIO_CANCELED.html" title="constant sdl3_sys::asyncio::SDL_ASYNCIO_CANCELED">SDL_<wbr>ASYNCIO_<wbr>CANCELED</a></div><div class="desc docblock-short">request was canceled before completing.</div></li><li><div class="item-name"><a class="constant" href="constant.SDL_ASYNCIO_COMPLETE.html" title="constant sdl3_sys::asyncio::SDL_ASYNCIO_COMPLETE">SDL_<wbr>ASYNCIO_<wbr>COMPLETE</a></div><div class="desc docblock-short">request was completed without error</div></li><li><div class="item-name"><a class="constant" href="constant.SDL_ASYNCIO_FAILURE.html" title="constant sdl3_sys::asyncio::SDL_ASYNCIO_FAILURE">SDL_<wbr>ASYNCIO_<wbr>FAILURE</a></div><div class="desc docblock-short">request failed for some reason; check <a href="../error/fn.SDL_GetError.html" title="fn sdl3_sys::error::SDL_GetError"><code>SDL_GetError()</code></a>!</div></li><li><div class="item-name"><a class="constant" href="constant.SDL_ASYNCIO_TASK_CLOSE.html" title="constant sdl3_sys::asyncio::SDL_ASYNCIO_TASK_CLOSE">SDL_<wbr>ASYNCIO_<wbr>TASK_<wbr>CLOSE</a></div><div class="desc docblock-short">A close operation.</div></li><li><div class="item-name"><a class="constant" href="constant.SDL_ASYNCIO_TASK_READ.html" title="constant sdl3_sys::asyncio::SDL_ASYNCIO_TASK_READ">SDL_<wbr>ASYNCIO_<wbr>TASK_<wbr>READ</a></div><div class="desc docblock-short">A read operation.</div></li><li><div class="item-name"><a class="constant" href="constant.SDL_ASYNCIO_TASK_WRITE.html" title="constant sdl3_sys::asyncio::SDL_ASYNCIO_TASK_WRITE">SDL_<wbr>ASYNCIO_<wbr>TASK_<wbr>WRITE</a></div><div class="desc docblock-short">A write operation.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.SDL_AsyncIOFromFile.html" title="fn sdl3_sys::asyncio::SDL_AsyncIOFromFile">SDL_<wbr>AsyncIO<wbr>From<wbr>File</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Use this function to create a new <a href="struct.SDL_AsyncIO.html" title="struct sdl3_sys::asyncio::SDL_AsyncIO"><code>SDL_AsyncIO</code></a> object for reading from
and/or writing to a named file.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_CloseAsyncIO.html" title="fn sdl3_sys::asyncio::SDL_CloseAsyncIO">SDL_<wbr>Close<wbr>AsyncIO</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Close and free any allocated resources for an async I/O object.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_CreateAsyncIOQueue.html" title="fn sdl3_sys::asyncio::SDL_CreateAsyncIOQueue">SDL_<wbr>Create<wbr>AsyncIO<wbr>Queue</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Create a task queue for tracking multiple I/O operations.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_DestroyAsyncIOQueue.html" title="fn sdl3_sys::asyncio::SDL_DestroyAsyncIOQueue">SDL_<wbr>Destroy<wbr>AsyncIO<wbr>Queue</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Destroy a previously-created async I/O task queue.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_GetAsyncIOResult.html" title="fn sdl3_sys::asyncio::SDL_GetAsyncIOResult">SDL_<wbr>GetAsyncIO<wbr>Result</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Query an async I/O task queue for completed tasks.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_GetAsyncIOSize.html" title="fn sdl3_sys::asyncio::SDL_GetAsyncIOSize">SDL_<wbr>GetAsyncIO<wbr>Size</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Use this function to get the size of the data stream in an <a href="struct.SDL_AsyncIO.html" title="struct sdl3_sys::asyncio::SDL_AsyncIO"><code>SDL_AsyncIO</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_LoadFileAsync.html" title="fn sdl3_sys::asyncio::SDL_LoadFileAsync">SDL_<wbr>Load<wbr>File<wbr>Async</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Load all the data from a file path, asynchronously.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_ReadAsyncIO.html" title="fn sdl3_sys::asyncio::SDL_ReadAsyncIO">SDL_<wbr>Read<wbr>AsyncIO</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Start an async read.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_SignalAsyncIOQueue.html" title="fn sdl3_sys::asyncio::SDL_SignalAsyncIOQueue">SDL_<wbr>Signal<wbr>AsyncIO<wbr>Queue</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Wake up any threads that are blocking in <a href="fn.SDL_WaitAsyncIOResult.html" title="fn sdl3_sys::asyncio::SDL_WaitAsyncIOResult"><code>SDL_WaitAsyncIOResult()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_WaitAsyncIOResult.html" title="fn sdl3_sys::asyncio::SDL_WaitAsyncIOResult">SDL_<wbr>Wait<wbr>AsyncIO<wbr>Result</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Block until an async I/O task queue has a completed task.</div></li><li><div class="item-name"><a class="fn" href="fn.SDL_WriteAsyncIO.html" title="fn sdl3_sys::asyncio::SDL_WriteAsyncIO">SDL_<wbr>Write<wbr>AsyncIO</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Start an async write.</div></li></ul></section></div></main></body></html>