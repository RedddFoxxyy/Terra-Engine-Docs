<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A realtime-safe single-producer single-consumer (SPSC) ring buffer."><title>rtrb - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rtrb" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rtrb/index.html">rtrb</a><span class="version">0.3.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>rtrb</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/rtrb/lib.rs.html#1-821">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A realtime-safe single-producer single-consumer (SPSC) ring buffer.</p>
<p>A <a href="struct.RingBuffer.html" title="struct rtrb::RingBuffer"><code>RingBuffer</code></a> consists of two parts:
a <a href="struct.Producer.html" title="struct rtrb::Producer"><code>Producer</code></a> for writing into the ring buffer and
a <a href="struct.Consumer.html" title="struct rtrb::Consumer"><code>Consumer</code></a> for reading from the ring buffer.</p>
<p>A fixed-capacity buffer is allocated on construction.
After that, no more memory is allocated (unless the type <code>T</code> does that internally).
Reading from and writing into the ring buffer is <em>lock-free</em> and <em>wait-free</em>.
All reading and writing functions return immediately.
Attempts to write to a full buffer return an error;
values inside the buffer are <em>not</em> overwritten.
Attempts to read from an empty buffer return an error as well.
Only a single thread can write into the ring buffer and a single thread
(typically a different one) can read from the ring buffer.
If the queue is empty, there is no way for the reading thread to wait
for new data, other than trying repeatedly until reading succeeds.
Similarly, if the queue is full, there is no way for the writing thread
to wait for newly available space to write to, other than trying repeatedly.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Moving single elements into and out of a queue with
<a href="struct.Producer.html#method.push" title="method rtrb::Producer::push"><code>Producer::push()</code></a> and <a href="struct.Consumer.html#method.pop" title="method rtrb::Consumer::pop"><code>Consumer::pop()</code></a>, respectively:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rtrb::{RingBuffer, PushError, PopError};

<span class="kw">let </span>(<span class="kw-2">mut </span>producer, <span class="kw-2">mut </span>consumer) = RingBuffer::new(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(producer.push(<span class="number">10</span>), <span class="prelude-val">Ok</span>(()));
<span class="macro">assert_eq!</span>(producer.push(<span class="number">20</span>), <span class="prelude-val">Ok</span>(()));
<span class="macro">assert_eq!</span>(producer.push(<span class="number">30</span>), <span class="prelude-val">Err</span>(PushError::Full(<span class="number">30</span>)));

std::thread::spawn(<span class="kw">move </span>|| {
    <span class="macro">assert_eq!</span>(consumer.pop(), <span class="prelude-val">Ok</span>(<span class="number">10</span>));
    <span class="macro">assert_eq!</span>(consumer.pop(), <span class="prelude-val">Ok</span>(<span class="number">20</span>));
    <span class="macro">assert_eq!</span>(consumer.pop(), <span class="prelude-val">Err</span>(PopError::Empty));
}).join().unwrap();</code></pre></div>
<p>See the documentation of the <a href="chunks/index.html#examples" title="mod rtrb::chunks"><code>chunks</code></a> module
for examples that write multiple items at once with
<a href="struct.Producer.html#method.write_chunk_uninit" title="method rtrb::Producer::write_chunk_uninit"><code>Producer::write_chunk_uninit()</code></a> and <a href="struct.Producer.html#method.write_chunk" title="method rtrb::Producer::write_chunk"><code>Producer::write_chunk()</code></a>
and read multiple items with <a href="struct.Consumer.html#method.read_chunk" title="method rtrb::Consumer::read_chunk"><code>Consumer::read_chunk()</code></a>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="chunks/index.html" title="mod rtrb::chunks">chunks</a></div><div class="desc docblock-short">Writing and reading multiple items at once into and from a <a href="struct.RingBuffer.html" title="struct rtrb::RingBuffer"><code>RingBuffer</code></a>.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Consumer.html" title="struct rtrb::Consumer">Consumer</a></div><div class="desc docblock-short">The consumer side of a <a href="struct.RingBuffer.html" title="struct rtrb::RingBuffer"><code>RingBuffer</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Producer.html" title="struct rtrb::Producer">Producer</a></div><div class="desc docblock-short">The producer side of a <a href="struct.RingBuffer.html" title="struct rtrb::RingBuffer"><code>RingBuffer</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RingBuffer.html" title="struct rtrb::RingBuffer">Ring<wbr>Buffer</a></div><div class="desc docblock-short">A bounded single-producer single-consumer (SPSC) queue.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.PeekError.html" title="enum rtrb::PeekError">Peek<wbr>Error</a></div><div class="desc docblock-short">Error type for <a href="struct.Consumer.html#method.peek" title="method rtrb::Consumer::peek"><code>Consumer::peek()</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.PopError.html" title="enum rtrb::PopError">PopError</a></div><div class="desc docblock-short">Error type for <a href="struct.Consumer.html#method.pop" title="method rtrb::Consumer::pop"><code>Consumer::pop()</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.PushError.html" title="enum rtrb::PushError">Push<wbr>Error</a></div><div class="desc docblock-short">Error type for <a href="struct.Producer.html#method.push" title="method rtrb::Producer::push"><code>Producer::push()</code></a>.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.CopyToUninit.html" title="trait rtrb::CopyToUninit">Copy<wbr>ToUninit</a></div><div class="desc docblock-short">Extension trait used to provide a <a href="trait.CopyToUninit.html#tymethod.copy_to_uninit" title="method rtrb::CopyToUninit::copy_to_uninit"><code>copy_to_uninit()</code></a>
method on built-in slices.</div></li></ul></section></div></main></body></html>